
A Technical Guide to Replicating the Messari Stablecoins Dashboard via API

This report provides a comprehensive, expert-level technical guide for developers and data analysts seeking to programmatically retrieve the data required to replicate the Messari Stablecoins dashboard. The analysis focuses exclusively on the Messari REST API, detailing the precise endpoints, parameters, and data-processing logic necessary to acquire the full dataset displayed on the webpage, with a primary emphasis on uncovering the list of "Asset Networks" for each stablecoin. The methodology presented herein is designed to be efficient, scalable, and resilient to future API changes by leveraging the latest and most appropriate endpoints.

Section 1: Foundational Access and API Architecture

Before any data can be retrieved, a foundational understanding of the Messari API's architecture, authentication model, and access protocols is essential. This section establishes the prerequisites for all subsequent API interactions, ensuring a stable and secure connection to the data services.

1.1 The Messari API Ecosystem

The Messari API is not a monolithic service but a comprehensive suite of specialized APIs designed to provide granular access to a wide array of cryptocurrency data.1 These services include the
Metrics API for market and on-chain data, the Signal API for social sentiment, Fundraising data, News, and more. This modular structure reflects a sophisticated, domain-driven internal architecture. For the purpose of this report, the Metrics API will be the primary tool, as it houses the endpoints for asset market data, metadata, and stablecoin-specific information.
A critical aspect to understand is that the Messari API directly powers the messari.io web application.2 This alignment ensures a high degree of data consistency between the API responses and what is displayed on the user-facing dashboards. Consequently, by correctly querying the API, it is possible to replicate the web interface with high fidelity.
All usage of the Messari API is governed by its Terms of Use and Privacy Policy. A key stipulation is that the API is intended for internal purposes only. Any form of data redistribution requires a separate, explicit license from Messari, a crucial legal consideration for any commercial application built upon this data.1

1.2 Authentication Protocol

Access to the Messari API is gated by a key-based authentication system. All requests must be authenticated to be successful.
API Key Generation and Usage
An API key can be generated by navigating to the API Access page within a registered Messari account (https://messari.io/account/api).2 This key must be included in every API request within the HTTP headers. The specific header required is
x-messari-api-key.2 Failure to include this header or providing an invalid key will result in an authentication error.
Rate Limiting
The API enforces rate limits, which vary based on the user's subscription level. For instance, users without a paid subscription are typically limited to 20 requests per minute and 1,000 requests per day, while Pro users receive higher limits.2 These limits have significant implications for application design. Any robust implementation must incorporate strategies to manage and respect these limits, such as implementing exponential backoff on rate-limiting error responses (HTTP status code
429 Too Many Requests) and designing data retrieval logic to be as efficient as possible, primarily through batching requests.
Security Best Practices
The API key should be treated with the same level of security as a password. It must never be shared publicly, committed to version control systems like Git, or embedded directly in client-side code (e.g., JavaScript in a public webpage) where it could be easily extracted.5 The recommended practice is to store the API key in a secure manner, such as an environment variable on the server, and have the application backend inject it into API requests.

1.3 API Base URL and Versioning

The primary base URL for accessing the data endpoints of the Messari API is https://data.messari.io/api.2 The API is versioned, with version identifiers included directly in the endpoint path (e.g.,
/v1/, /v2/).
The existence of multiple versions for similar resources (e.g., /v1/assets and /v2/assets) is a critical detail. This versioning indicates an evolving API strategy and the introduction of new features or data structures over time. It is imperative for developers to use the latest, non-deprecated version of an endpoint to ensure access to the most complete and current data fields and to avoid building applications on legacy endpoints that may be sunset in the future. The documentation explicitly marks older endpoints, such as deprecated /asset/v1/assets, as obsolete.7 This report will exclusively utilize the most current
v2 endpoints where available, as they provide the necessary parameters and data fields to fulfill the query's requirements.

1.4 Making a Test Request

To confirm that the environment is correctly configured with a valid API key, a simple test request can be made. The following Python code snippet demonstrates how to make a basic GET request to the /v2/assets endpoint to fetch data for Bitcoin, including the necessary authentication header.

Python


import os
import requests
import json

# Best practice: Store the API key as an environment variable
API_KEY = os.getenv("MESSARI_API_KEY")
BASE_URL = "https://data.messari.io/api"

def make_test_request():
    """
    Makes a simple test request to the Messari API to verify authentication.
    """
    if not API_KEY:
        print("Error: MESSARI_API_KEY environment variable not set.")
        return

    headers = {
        "x-messari-api-key": API_KEY
    }
    
    # Endpoint to get basic data for a single asset (Bitcoin)
    endpoint = "/v2/assets/btc"
    
    try:
        response = requests.get(f"{BASE_URL}{endpoint}", headers=headers)
        
        # Raise an exception for bad status codes (4xx or 5xx)
        response.raise_for_status()
        
        # If the request was successful (status code 200)
        print("Successfully connected to the Messari API.")
        
        # Parse and print the JSON response
        data = response.json()
        print(json.dumps(data, indent=2))
        
    except requests.exceptions.HTTPError as http_err:
        print(f"HTTP error occurred: {http_err}")
        print(f"Response content: {response.text}")
    except Exception as err:
        print(f"An other error occurred: {err}")

# Run the test
make_test_request()


A successful execution of this script, resulting in a 200 OK status and a JSON payload containing Bitcoin's data, confirms that the authentication and base URL are correctly configured for the subsequent steps.
Table 1.1: Core API Endpoint Reference
This table serves as a quick-reference guide to the primary API endpoints that will be utilized throughout this report to achieve the final objective.
Purpose
HTTP Method
Endpoint Path
Primary Function
List All Stablecoins
GET
/metrics/v2/stablecoins
Enumerates all assets classified as stablecoins by Messari.
Get Detailed Asset Data (Metrics & Profiles)
GET
/api/v2/assets
Retrieves comprehensive data for one or more assets, including the crucial network information.
List All Networks (For Enrichment)
GET
/metrics/v1/networks
Provides a list of all blockchain networks tracked by Messari.


Section 2: Step 1 - Enumerating All Stablecoin Assets

The foundational step in replicating the stablecoins dashboard is to obtain a definitive list of all assets that Messari classifies as stablecoins. This list will provide the unique identifiers required to fetch detailed metrics and profile data in subsequent steps.

2.1 Identifying the Correct Endpoint

The Messari API provides a dedicated endpoint specifically for this purpose: GET /metrics/v2/stablecoins.9 This endpoint is the most direct and reliable method for enumerating stablecoins. While it might be theoretically possible to filter the general
GET /api/v2/assets endpoint by a "stablecoin" category or tag, using the purpose-built /metrics/v2/stablecoins endpoint is superior. It guarantees that the returned list aligns precisely with Messari's internal "Stablecoins" dataset, ensuring accuracy and removing any ambiguity from the filtering logic.3

2.2 Request Structure and Parameters

The GET /metrics/v2/stablecoins endpoint is straightforward to use. The official documentation indicates that it does not require any query parameters for a complete listing.9 A simple authenticated
GET request to the full URL is sufficient.
Full Request URL: https://data.messari.io/api/metrics/v2/stablecoins

2.3 Deconstructing the Response Payload

A successful request to this endpoint returns a JSON object containing a data key, which holds an array of stablecoin objects. Each object in this array represents a single stablecoin and contains essential identifiers. The most critical fields for our purposes are:
id: A unique UUID assigned by Messari to the asset (e.g., 1e31218a-e44e-4285-820c-8282ee152caf for Tether). This is the most stable, long-term identifier.
symbol: The commonly known ticker for the asset (e.g., USDT).
name: The full name of the asset (e.g., Tether).
slug: A human-readable, URL-friendly identifier (e.g., tether).
While all these identifiers are useful for display purposes, the id or slug will be used as the primary key for querying detailed asset data in the next steps. The slug is often more convenient for use in other API calls.
It is important to properly set expectations about the data returned by this endpoint. The documentation states that it returns a list of stablecoins "along with coverage data".9 In the context of a data provider like Messari, "coverage" typically refers to the scope and completeness of their own datasets for a given asset—for example, the date range for which they have historical price data or the number of metrics they track. This term does not refer to the asset's intrinsic properties, such as the on-chain networks where it is deployed. Therefore, this initial endpoint serves only to enumerate the target assets; it will not provide the "Asset Networks" information, which must be sought from a different source.
Furthermore, a footnote in the API documentation reveals a key detail about data lineage: "Messari sources stablecoin data from Token Terminal".3 This is a significant piece of information for any user performing serious due diligence. It indicates that the stablecoin metrics provided by Messari are not generated in-house but are ingested from a specialized third-party provider.11 This knowledge is valuable for understanding the methodology behind the data and for tracing the source of any potential discrepancies when comparing API data against on-chain reality.

Section 3: Step 2 - Acquiring Core Financial Metrics

With a complete list of stablecoin identifiers, the next step is to retrieve the core financial metrics for each asset. These metrics correspond directly to the main columns displayed on the Messari stablecoins webpage: Price, 24-hour Volume, Market Capitalization, and the percentage changes in market capitalization over various timeframes.

3.1 Selecting the Optimal Endpoint

The most efficient and powerful endpoint for this task is GET /api/v2/assets.4 While other, more specific endpoints for market data exist, this
v2 endpoint is superior for two key reasons. First, it supports batch requests, allowing the retrieval of data for multiple assets in a single API call. Second, it can be instructed to return both quantitative metrics and qualitative profile data simultaneously, which will be leveraged in the next section to acquire the "Asset Networks" information.
To use this endpoint effectively, the asset identifiers (preferably the slugs) obtained in Section 2 should be compiled into a single comma-separated string and passed to the assetKeys query parameter.
Example Request Structure:
GET https://data.messari.io/api/v2/assets?assetKeys=tether,usd-coin,dai
This approach is vastly more performant than making individual API calls for each stablecoin. A naive, iterative approach would quickly encounter rate limits and result in slow data acquisition. The correct architectural pattern is to collect all necessary asset identifiers first, group them into reasonably sized chunks (e.g., 50-100 per request, depending on URL length limits), and then execute these batched requests. This "batching" strategy is fundamental to building a scalable and efficient application on top of the Messari API.

3.2 Deconstructing the metrics Object

The response from the /api/v2/assets endpoint will contain an array of asset objects. Within each asset object, there is a metrics key, which holds a nested JSON object containing a rich set of quantitative data. The webpage can be replicated by mapping its columns to the specific fields within this metrics object.
It is noteworthy that the API response is far more comprehensive than the data displayed on the webpage UI. The metrics object contains a wealth of additional information, including ROI data, all-time-high data, various supply metrics, and more.12 This presents an opportunity for a developer to not only replicate the existing dashboard but to significantly enhance it with more detailed analytics, all from the same API call.
Table 3.1: Webpage Metric to API Field Mapping
This table provides the definitive mapping between the data columns on the Messari Stablecoins webpage and their corresponding JSON paths within the API response. It serves as a practical "Rosetta Stone" for developers, eliminating ambiguity and accelerating the implementation process.
Webpage Column Display
API JSON Path
Description
Data Type
Price Current
metrics.market_data.price_usd
The current price of the asset, denominated in USD.
Number
Volume 24H
metrics.market_data.volume_last_24_hours
The total trading volume over the preceding 24 hours, in USD.
Number
Marketcap
metrics.marketcap.current_marketcap_usd
The current market capitalization of the asset, in USD.
Number
Marketcap 7D Change
metrics.marketcap.percent_change_last_7_days
The percentage change in market capitalization over the last 7 days.
Number
Marketcap 30D Change
metrics.marketcap.percent_change_last_30_days
The percentage change in market capitalization over the last 30 days.
Number
Marketcap 1Y Change
metrics.marketcap.percent_change_last_1_year
The percentage change in market capitalization over the last 1 year.
Number


Section 4: The Core Investigation - Uncovering Asset Networks via Asset Profiles

This section addresses the central and most challenging requirement of the user's query: determining the method to retrieve the list of "Asset Networks" on which each stablecoin is deployed. The solution is not immediately obvious from the stablecoin-specific endpoints and requires a deeper understanding of how Messari structures its asset data.

4.1 The Hypothesis: Networks are part of the Asset Profile

Analysis of the stablecoin-specific endpoints in Section 2 confirmed that they do not contain deployment network information. This leads to the hypothesis that Messari considers an asset's multi-chain deployments to be a fundamental, relatively static piece of its identity, rather than a dynamic, quantitative metric. As such, this information is most likely to be found within the asset's "profile" data. This distinction is key to understanding Messari's data model: metrics are for data that changes frequently (price, volume), while profile is for foundational, qualitative information (project description, official links, and, as will be shown, contract addresses).

4.2 The Solution: The with-profiles=true Parameter

The GET /api/v2/assets endpoint, already identified as the optimal choice for fetching metrics, holds the key to this problem. This endpoint accepts a boolean query parameter, with-profiles, which, when set to true, instructs the API to include the detailed profile object alongside the metrics in the response.13
Therefore, the most efficient strategy is to combine the requests from Section 3 and Section 4 into a single, powerful API call. By including both the assetKeys and with-profiles=true parameters, all the data needed to replicate the entire dashboard—both financial metrics and network information—can be retrieved in one batched request.
Optimized Request Structure:
GET https://data.messari.io/api/v2/assets?assetKeys={ASSET_SLUGS}&with-profiles=true

4.3 Locating and Parsing the contract_addresses Field

When the with-profiles=true parameter is used, the response for each asset will include a profile object. The critical data field is located at the path profile.contract_addresses.13 This field contains an array of objects, where each object represents a single deployment of the stablecoin on a specific blockchain network.
The structure of these objects is consistent and provides the necessary information. By deconstructing one of these objects, the path to the network name becomes clear.
Table 4.1: Deconstruction of the contract_addresses Object
This table provides an annotated example of a single object from the profile.contract_addresses array, illustrating the structure and significance of each key.
Key
Example Value
Data Type
Significance
blockchain
"Ethereum"
String
This is the "Asset Network." It is the name of the blockchain on which the contract is deployed.
address
"0xdAC17F958D2ee523a2206206994597C13D831ec7"
String
The smart contract address of the stablecoin token on the specified blockchain.


4.4 Deriving the Final Data Points

With the profile.contract_addresses array identified, deriving the two required data points shown on the Messari UI is straightforward. The UI's presentation of "Asset Networks" is a user-friendly abstraction of this raw API data, and the logic to replicate it is as follows:
To get the total count of "Asset Networks": The count is simply the length of the profile.contract_addresses array. For example, if the array for Tether contains 35 objects, the "Asset Networks" count is 35.
To get the list of individual "Asset Networks": The list is generated by iterating through the profile.contract_addresses array and extracting the value of the blockchain key from each object. The result is a list of strings (e.g., ``).
This process successfully bridges the gap between the raw, structured data provided by the API and the polished, aggregated information presented on the webpage, providing the developer with the exact transformation logic required.

Section 5: A Synthesized, Step-by-Step Implementation Strategy

This final section consolidates all the preceding analysis into a single, actionable implementation plan. It presents a complete algorithm in pseudocode and a full, production-quality Python script that executes the entire data retrieval and processing workflow.

5.1 The Complete Algorithm (Pseudocode)

The entire process can be optimized into a highly efficient, two-stage "index-then-fetch" pattern. The first stage indexes all target assets, and the second stage fetches all required data in batches.
START
DEFINE API_KEY and standard HTTP HEADERS
// STAGE 1: INDEX STABLECOINS
MAKE request to GET /metrics/v2/stablecoins
IF request is successful:
 `PARSE response to extract a list of all stablecoin slugs` -> `stablecoin_slugs`


ELSE:
 `HANDLE error and EXIT`


// STAGE 2: FETCH DETAILED DATA IN BATCHES
DEFINE BATCH_SIZE (e.g., 50)
SPLIT stablecoin_slugs into chunks of BATCH_SIZE -> slug_chunks
INITIALIZE empty list for all detailed data -> all_assets_data
FOR each chunk in slug_chunks:
`CONSTRUCT comma-separated string from chunk` -> `asset_keys_string`


`MAKE request to GET /api/v2/assets?assetKeys={asset_keys_string}&with-profiles=true`


`IF request is successful:`


    `EXTRACT asset data from response and APPEND to all_assets_data`


`ELSE:`


    `LOG warning for the failed batch`


// STAGE 3: PROCESS AND SYNTHESIZE FINAL DATA STRUCTURE
INITIALIZE empty list for final results -> final_results
FOR each raw_asset in all_assets_data:
`CREATE a new, clean asset object`


`EXTRACT name, symbol from raw_asset`


`EXTRACT price, volume, marketcap, changes from raw_asset.metrics`


`INITIALIZE network_list =`


`CALCULATE network_count = 0`


`IF raw_asset.profile.contract_addresses exists:`


    `CALCULATE network_count = length of raw_asset.profile.contract_addresses`


    `FOR each deployment in raw_asset.profile.contract_addresses:`


        `APPEND deployment.blockchain to network_list`


`POPULATE the clean asset object with all extracted data`


`APPEND the clean asset object to final_results`


PRINT or RETURN final_results
END
This algorithm highlights the developer's final role not just as a data fetcher, but as a data modeler. The API provides data in a structure optimized for its own systems; the developer's task is to execute this logic to transform and synthesize the raw responses into a coherent data model suitable for their application's needs.

5.2 Full Python Implementation

The following Python script provides a complete, commented implementation of the algorithm described above. It incorporates best practices such as using environment variables for the API key, handling potential HTTP errors, batching requests, and processing the data into a final, clean structure.

Python


import os
import requests
import json
from typing import List, Dict, Any

# --- Configuration ---
API_KEY = os.getenv("MESSARI_API_KEY")
BASE_URL = "https://data.messari.io/api"
BATCH_SIZE = 50 # Number of assets to request in a single API call

def get_all_stablecoin_slugs() -> List[str]:
    """
    Fetches the complete list of stablecoin slugs from the Messari API.
    
    Returns:
        A list of asset slugs (e.g., ['tether', 'usd-coin']).
    """
    if not API_KEY:
        raise ValueError("MESSARI_API_KEY environment variable not set.")

    headers = {"x-messari-api-key": API_KEY}
    endpoint = "/metrics/v2/stablecoins"
    
    print("Fetching list of all stablecoins...")
    
    try:
        response = requests.get(f"{BASE_URL}{endpoint}", headers=headers)
        response.raise_for_status()
        data = response.json()
        
        slugs = [asset['slug'] for asset in data.get('data',) if 'slug' in asset]
        print(f"Found {len(slugs)} stablecoins.")
        return slugs
    except requests.exceptions.HTTPError as http_err:
        print(f"HTTP error occurred while fetching stablecoin list: {http_err}")
        print(f"Response content: {response.text}")
        return
    except Exception as err:
        print(f"An other error occurred: {err}")
        return

def get_detailed_asset_data(slugs: List[str]) -> List]:
    """
    Fetches detailed metrics and profile data for a list of asset slugs in batches.
    
    Args:
        slugs: A list of asset slugs.
        
    Returns:
        A list of raw asset data objects from the API.
    """
    if not slugs:
        return
        
    headers = {"x-messari-api-key": API_KEY}
    endpoint = "/v2/assets"
    all_assets_data =
    
    # Split slugs into batches
    for i in range(0, len(slugs), BATCH_SIZE):
        batch = slugs
        asset_keys_string = ",".join(batch)
        
        params = {
            "assetKeys": asset_keys_string,
            "with-profiles": "true"
        }
        
        print(f"Fetching detailed data for batch {i//BATCH_SIZE + 1}...")
        
        try:
            response = requests.get(f"{BASE_URL}{endpoint}", headers=headers, params=params)
            response.raise_for_status()
            data = response.json()
            all_assets_data.extend(data.get('data',))
        except requests.exceptions.HTTPError as http_err:
            print(f"HTTP error on batch {i//BATCH_SIZE + 1}: {http_err}")
            print(f"Response content: {response.text}")
            continue # Continue to the next batch
            
    return all_assets_data

def process_and_synthesize_data(raw_assets: List]) -> List]:
    """
    Processes raw API data into a final, clean data structure.
    
    Args:
        raw_assets: A list of raw asset data objects from the API.
        
    Returns:
        A list of processed and structured asset objects.
    """
    final_results =
    for asset in raw_assets:
        # Safely get nested values using.get() to avoid errors on missing keys
        metrics = asset.get('metrics', {})
        market_data = metrics.get('market_data', {})
        marketcap = metrics.get('marketcap', {})
        profile = asset.get('profile', {})
        contract_addresses = profile.get('contract_addresses',)

        # Process network information
        network_count = len(contract_addresses) if contract_addresses else 0
        network_list = [net['blockchain'] for net in contract_addresses if 'blockchain' in net]

        processed_asset = {
            "name": asset.get('name'),
            "symbol": asset.get('symbol'),
            "price_usd": market_data.get('price_usd'),
            "volume_24h_usd": market_data.get('volume_last_24_hours'),
            "marketcap_usd": marketcap.get('current_marketcap_usd'),
            "marketcap_change_7d_percent": marketcap.get('percent_change_last_7_days'),
            "marketcap_change_30d_percent": marketcap.get('percent_change_last_30_days'),
            "marketcap_change_1y_percent": marketcap.get('percent_change_last_1_year'),
            "asset_networks_count": network_count,
            "asset_networks_list": network_list
        }
        final_results.append(processed_asset)
        
    return final_results

def main():
    """
    Main function to execute the data retrieval and processing workflow.
    """
    stablecoin_slugs = get_all_stablecoin_slugs()
    if stablecoin_slugs:
        raw_asset_data = get_detailed_asset_data(stablecoin_slugs)
        if raw_asset_data:
            final_data = process_and_synthesize_data(raw_asset_data)
            
            # Sort by marketcap descending to match the webpage
            final_data.sort(key=lambda x: x.get('marketcap_usd') or 0, reverse=True)
            
            print("\n--- Processed Stablecoin Data ---")
            print(json.dumps(final_data, indent=2))
            print(f"\nSuccessfully processed data for {len(final_data)} stablecoins.")

if __name__ == "__main__":
    main()



5.3 Enriching the Data (Optional Advanced Step)

To fully replicate the user interface, which displays logos for each asset network, an additional data enrichment step can be performed. The list of network names extracted (e.g., "Ethereum", "Solana") can be used to query another Messari endpoint: GET /metrics/v1/networks.15
This endpoint returns a list of all networks tracked by Messari, along with their associated metadata. While the documentation does not explicitly confirm the presence of a logo URL, this would be the logical location for such information. By fetching data from this endpoint and creating a mapping from network name to its metadata (including a potential logo URL), the developer can build a more visually complete replication of the dashboard.

Conclusion

Replicating the Messari Stablecoins dashboard is an achievable technical objective that requires a precise, multi-step interaction with the Messari API. The core challenge—retrieving the "Asset Networks"—is solved not through a direct, single-purpose endpoint, but by understanding the API's data model and leveraging the qualitative profile data available through the GET /api/v2/assets endpoint.
The optimal strategy involves a two-stage process: first, enumerating all target assets using the dedicated GET /metrics/v2/stablecoins endpoint, and second, executing batched requests to the GET /api/v2/assets endpoint with the with-profiles=true parameter. This approach is highly efficient, minimizing the number of API calls and respecting rate limits, while simultaneously retrieving all necessary financial metrics and network deployment information. By following the detailed algorithm and implementation provided in this report, developers can successfully acquire the required data and build a robust, accurate, and data-rich application that mirrors the functionality of the official Messari interface.
Works cited
Introduction - Messari Docs, accessed August 24, 2025, https://docs.messari.io/reference/introduction
Messari | Crypto Data | Postman API Network, accessed August 24, 2025, https://www.postman.com/blockchaintechdata/crypto-data/folder/weofl70/messari
Stablecoins - Messari Docs, accessed August 24, 2025, https://docs.messari.io/reference/stablecoins
Connect Messari To Google Sheets [Integration] - Apipheny, accessed August 24, 2025, https://apipheny.io/messari-api/
Authentication - Messari Docs, accessed August 24, 2025, https://docs.messari.io/reference/authentication
How to Fetch Cryptocurrency Data Using Messari API in Python - Omi AI, accessed August 24, 2025, https://www.omi.me/blogs/api-guides/how-to-fetch-cryptocurrency-data-using-messari-api-in-python
Assets - Messari Docs, accessed August 24, 2025, https://docs.messari.io/reference/assets-4
Asset by ID - Messari Docs, accessed August 24, 2025, https://docs.messari.io/reference/asset-by-id
List Stablecoins - Messari Docs, accessed August 24, 2025, https://docs.messari.io/reference/list-stablecoins
Assets - Messari Docs, accessed August 24, 2025, https://docs.messari.io/docs/assets-dataset
Token Terminal | Fundamentals for crypto, accessed August 24, 2025, https://tokenterminal.com/
Assets v2 - Messari Docs, accessed August 24, 2025, https://docs.messari.io/reference/asset-package
How to pull Get All Assets V2 data from Messari into Excel and ..., accessed August 24, 2025, https://docs.cryptosheets.com/providers/messari/get-all-assets-v2/
CryptoIntel.app Comprehensive Technical Whitepaper - Supabase, accessed August 24, 2025, https://qtrypzzcjebvfcihiynt.supabase.co/storage/v1/object/public/base44-prod/public/03dba7a0c_CryptoIntel_Comprehensive_Merged_Whitepaper.pdf
List Networks - Messari Docs, accessed August 24, 2025, https://docs.messari.io/reference/metrics-networks-list-networks
